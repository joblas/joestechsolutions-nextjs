{
  "id": "6d795eccce114ee2c911e957ba30b6d2",
  "source_type": "article",
  "source_url": "https://www.joshwcomeau.com/animation/color-shifting/",
  "title": "Color Shifting in CSS â€¢ Josh W. Comeau",
  "author": "Josh W Comeau",
  "publish_date": "2025-09-08T00:00:00",
  "raw_content": "---\ntitle: Color Shifting in CSS â€¢ Josh W. Comeau\nauthor: Josh W Comeau\ndescription: A little while ago, I was trying to animate an elementâ€™s background color, so that it cycled through the rainbow. Seems easy, but it turns out, browsers have a surprisingly big limitation when it comes to color processing! In this tutorial, weâ€™ll dig into the issue, and Iâ€™ll share a couple of strategies you can use to work around this limitation.\nsitename: Josh W. Comeau\ndate: 2025-09-08\n---\nLetâ€™s suppose weâ€™re building this particle effect:\nThis effect is something we build in my brand-new animations course(opens in new tab), and there are lots of little details, but in this blog post, I want to zoom in on one surprisingly-interesting facet: the color shifting.\nEach particle starts on a random color and changes hue as it fades out. This seems pretty straightforward, but appearances can be deceiving. In fact, I discovered a new CSS limitation I wasnâ€™t aware of, and came up with a couple different workarounds.\nIn this tutorial, Iâ€™ll share what Iâ€™ve learned, and youâ€™ll see how to build some super-cool color-shifting effects in CSS!\nLink to this headingHello color\nSo, in my particle effect, I want every particle to have its own dynamic colors.\nLetâ€™s start with the simplest possible option, generating a random color using RGB values:\n// Do this for every particle:\nconst red = Math.round(Math.random() * 255);\nconst green = Math.round(Math.random() * 255);\nconst blue = Math.round(Math.random() * 255);\nparticle.style.backgroundColor =\n`rgb(${red} ${green} ${blue})`;\nThe RGB color format supports 16.7 million possible colors (2563), and this code will select one of them, totally at random. Hereâ€™s what that looks like:\nSample Colors\n(ClickTap the heart to generate some particles. The first few colors will be shown here.)\nThis looks alright, but we probably donâ€™t want to use completely random colors. It would feel a lot more cohesive if all of our colors had the same general feel (eg. all pastel colors, or all neon colors).\nItâ€™s not at all obvious how we would do this with rgb()\n, but if we switch to hsl()\n, things get a lot easier. We could do something like this:\nconst randomHue = Math.round(\nMath.random() * 359\n);\nparticle.style.backgroundColor =\n`hsl(${randomHue}deg 100% 80%)`;\nIn this updated version, weâ€™re picking a random hue, but weâ€™re keeping the saturation locked to 100% and the lightness locked to 80%. This produces pastel-like tones:\nSample Colors\n(ClickTap the heart to generate some particles. The first few colors will be shown here.)\nThis feels a lot better to me. The only issue is that randomness can be clumpy; thereâ€™s no guarantee that the selected hues will be distributed across the color wheel. But this wonâ€™t really be an issue when we start shifting between colors, so letâ€™s not worry about it.\nLink to this headingShifting between colors\nAlright, so Iâ€™m happy with our single-color solution, but really our goal is for each particle to shift between two different colors.\nAs I mentioned in the intro, this was surprisingly tricky. Hereâ€˜s the first thing I tried:\nconst fromHue = Math.round(\nMath.random() * 359\n);\nconst toHue = fromHue + 180;\nparticle.style.setProperty(\n'--from-color',\n`hsl(${fromHue}deg 100% 80%)`\n);\nparticle.style.setProperty(\n'--to-color',\n`hsl(${toHue}deg 100% 80%)`\n);\n/* And then, in the CSS: */\n@keyframes colorShift {\nfrom {\nbackground: var(--from-color);\n}\n}\n.particle {\nbackground-color: var(--to-color);\nanimation: colorShift 1500ms linear;\n}\nIn this updated version, Iâ€™m generating two HSL colors that are on opposite sides of the color wheel, and fading between them using a keyframe animation. Iâ€™m using a couple of keyframe tricks that I wrote about a few weeks back.\nI chose a linear timing function since it feels more natural in this particular case; each intermediate color is shown for the same amount of time.\nHereâ€˜s what this looks like:\nSample Colors\n(ClickTap the heart to generate some particles. The first few colors will be shown here.)\nWhat do you think about this? Take a moment to really examine it. Do the colors look good to you?\nPersonally, I found that the colors seemed a bit washed out. The particles become sorta grey-ish in between the source and destination. ðŸ¤”\nThis is clearer if we zoom in and slow down:\nIf you pause this video while the particles are halfway through their shift, theyâ€™re all greyscale!\nAdmittedly, itâ€™s hard to tell with everything going on. Hereâ€™s a basic button that performs the same color transition on hover/focus:\nCode Playground\n<style> button { background: hsl(0deg 100% 65%); transition: all 2000ms; &:hover, &:focus-visible { background:hsl(180deg 100% 65%); } } </style> <button> Hover over me </button>\nThe starting color (red) and the ending color (teal) are both quite vibrant, but it becomes dull and grey in the middle:\nI would expect that the saturation and lightness would stay the same, and only the hue would shift through the animation, something like this:\nHereâ€™s the problem: when we animate background-color\n, the browser always does the calculations using the RGB color space, even when our colors are specified in HSL.\nIn RGB, we have three color channels (red/green/blue), each between 0 and 255. The browser does the math on these three channels individually. You can see why thatâ€™s a problem in this demo:\nHow to use: Click and drag to reposition the indicator, or focus the indicator and use the left/right arrow keys.\nAs we scroll from left to right, the red channel decreases as the green/blue channels increase. As a result, all three channels converge on the same value in the middle, producing a medium gray.\nIn other words, the browser is transitioning between these two colors using a mathematical model that doesnâ€™t really have anything to do with how we perceive color ðŸ˜…. No rational person would say that the midpoint between red and teal is grey!\nThereâ€™s another issue, too. Letâ€™s say we wanted the color to rotate by a full 360Â°, looping around the color wheel. Check out what happens when we try to transition between 0Â° and 360Â°:\nCode Playground\n<style> button { background: hsl(0deg 100% 65%); transition: background 2000ms; &:hover, &:focus-visible { font-weight: bold; background: hsl(360deg 100% 65%); } } </style> <button> Hover over me </button>\nNothing happens. Youâ€™re not doing it wrong. Hovering or focusing the button doesnâ€™t seem to affect the background color at all. ðŸ¤”\nIn order to understand whatâ€™s going on here, we have to answer a philosophical question: are hsl(0deg 100% 65%)\nand hsl(360deg 100% 65%)\nthe same color?\nWell, they represent something different; 0deg\nrepresents the very first color available in the spectrum, while 360deg\nrepresents a full spin around the color wheel. But ultimately, both colors resolve to the same R/G/B values.\nUnfortunately, as we saw above, the browser doesnâ€™t do color interpolations in HSL; it first converts both values to rgb()\nand then transitions the values for all three color channels. And since hsl(0deg 100% 65%)\nand hsl(360deg 100% 65%)\nboth resolve to the exact same rgb()\nvalue, we wind up not transitioning at all.\nFortunately, I found a solution that solves these problems, and offers better performance to boot. âš¡\nLink to this headingCSS filters to the rescue!\nIf youâ€™re not familiar, the CSS filter\nproperty provides SVG-style filters in CSS. For example, we can blur an element with filter: blur()\n:\nCode Playground\n<style> img { /* Change this value to affect the blur amount: */ filter: blur(6px); } </style> <img alt=\"A blurry 3D illustration of Josh\" src=\"/img/josh-mascot.png\" />\nOne of the filters is hue-rotate\n. As youâ€™d expect, this filter shifts the hue of a given element:\nLetâ€™s update our particle effect to use the hue-rotate()\nfilter. On the JavaScript side, we can actually revert to what we had earlier, setting the particleâ€™s background color:\nconst randomHue = Math.round(\nMath.random() * 359\n);\nparticle.style.backgroundColor =\n`hsl(${randomHue}deg 100% 80%)`;\nOn the CSS side, weâ€™ll create a new keyframe animation that will do two full spins around the color wheel:\n@keyframes hueRotate {\nto {\nfilter: hue-rotate(720deg);\n}\n}\n.particle {\nanimation: hueRotate 1000ms;\n}\nAnd hereâ€™s what that looks like:\nSample Colors\n(ClickTap the heart to generate some particles. The first few colors will be shown here.)\nIt works! Each particle is able to rotate more than 180 degrees. ðŸ˜„\nNow, itâ€™s not quite the same as changing the hue component of an hsl()\ncolor. Hereâ€™s a side-by-side comparison:\nIâ€™m not exactly sure how the filter: hue-rotate()\nalgorithm works, but it tends to produce darker color variations. Iâ€™ve found it works best if I pick slightly lighter and less-saturated colors.\nAnd honestly, I think two full rotations (720deg\n) is probably a bit much. I wanted to make sure the effect was clear in this demo, but in practice, Iâ€™d probably pick a smaller value, maybe something in the 180Â°-540Â° range.\nLink to this headingTwinkling\nAnother small detail that makes a surprisingly big difference is the twinkling effect; as the particles fade away, they flicker a bit. Itâ€™s not a simple linear fade from full opacity to full transparency.\nI accomplished this using the partial keyframes trick I shared a few weeks back. Hereâ€™s the basic idea:\n@keyframes fadeToTransparent {\nto {\nopacity: 0;\n}\n}\n@keyframes twinkle {\nfrom {\nopacity: var(--twinkle-amount);\n}\nto {\nopacity: 1;\n}\n}\n.particle {\nanimation:\ntwinkle var(--twinkle-duration) infinite alternate ease-in-out,\nfadeToTransparent var(--fade-duration) 500ms;\n}\nOne of my little animation secrets is to add small bits of random variation to everything. Each particle defines its own --twinkle-duration\nand --twinkle-amount\n, so that they donâ€™t all flicker in lockstep like christmas tree lights.\nLink to this headingWhimsical Animations\nIf youâ€™d like to learn how to build this full particle effect, along with tons of other cool animations and interactions, I have great news for you!\nIâ€™ve spent this year building a comprehensive, interactive online course all about whimsical animations. I share all of my most potent tricks and techniques. If youâ€™ve ever wondered how I built some special effect on this blog, thereâ€™s a very good chance this course contains the answer. ðŸ˜„\nIâ€™m hoping to release this course in the first half of 2026. You can learn more and sign up here:\nLast updated on\nOctober 25th, 2025",
  "metadata": {
    "site": "Josh W. Comeau"
  },
  "status": "ingested",
  "blog_content": null,
  "social_content": null,
  "google_doc_id": null,
  "error_message": null,
  "created_at": "2026-01-24T09:06:47.547851",
  "updated_at": "2026-01-24T09:06:47.547851"
}