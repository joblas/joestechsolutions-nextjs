{
  "id": "96a150cb96e8f4de5f4f570f82a20244",
  "source_type": "article",
  "source_url": "https://www.joshwcomeau.com/css/starting-style/",
  "title": "The Big Gotcha With @starting-style ‚Ä¢ Josh W. Comeau",
  "author": "Josh W Comeau",
  "publish_date": "2025-09-22T00:00:00",
  "raw_content": "---\ntitle: The Big Gotcha With @starting-style ‚Ä¢ Josh W. Comeau\nauthor: Josh W Comeau\ndescription: CSS has been on fire lately, with tons of great new features. @starting-style is an interesting one; it allows us to use CSS transitions for enter animations, something previously reserved for CSS keyframe animations. But is the juice worth the squeeze?\nsitename: Josh W. Comeau\ndate: 2025-09-22\n---\nHave you heard of the @starting-style\nat-rule? It‚Äôs an interesting new tool that lets us use CSS transitions for enter animations.\nFor example, let‚Äôs suppose we have some UI where elements get added dynamically to the page, and we want them to fade in:\nCode Playground\n<style> @keyframes fadeFromTransparent { from { opacity: 0; } } .box { animation: fadeFromTransparent 1000ms; } </style> <button id=\"triggerBtn\"> Add Element </button>\nWhen you click the ‚ÄúAdd Element‚Äù button, a new purple square is generated and added to the page, and a CSS keyframe animation fades it in over 1 second.\nHistorically, the big limitation with CSS transitions has been that they only apply when a targeted CSS property changes from one value to another. If we want a property to animate when an element is created, we‚Äôve needed to use CSS keyframe animations, like I‚Äôm doing in the example above.\nThe new @starting-style\nAPI is a workaround for this limitation. We can provide an alternative set of CSS declarations. When the element is created, it‚Äôll immediately transition from these initial styles.\nCheck it out:\nCode Playground\n<style> .box { opacity: 1; transition: opacity 1000ms; @starting-style { opacity: 0; } } </style> <button id=\"triggerBtn\"> Add Element </button>\nEach .box\nelement gets initialized with opacity: 0\n, set within the @starting-style\nblock. Right after the element is created, that declaration is removed, triggering a CSS transition to opacity: 1\n, set within the main styles.\nThis is pretty cool, but there‚Äôs a catch. The CSS within @starting-style\nisn‚Äôt handled by the browser in the same way as the CSS within @keyframes\n, and this can lead to some problems. üò¨\nIn this blog post, we‚Äôll dig into the issue I found with this API and explore some workarounds. In the process, we‚Äôll learn quite a bit about CSS specificity, so even if you‚Äôre not particularly interested in @starting-style\n, I bet this‚Äôll still be worth your while!\nLink to this headingThe specificity problem\nIf you‚Äôve worked with CSS for a while, you probably know about specificity. When our CSS contains rules that conflict with each other, the browser has a system to work out which CSS should actually be applied.\nFor example, consider this setup:\n<button class=\"primary-button\">\nHello World\n</button>\n<style>\nbutton {\nbackground-color: transparent;\n}\n.primary-button {\nbackground-color: blue;\n}\n</style>\nThis snippet contains two rules, and they both match that <button>\nelement. Each rule sets the background-color\nproperty to a different value. The button can‚Äôt simultaneously be both transparent\nand blue\n. How does the browser decide which value to apply?\nAccording to the specificity rules, class selectors like .primary-button\nare more specific than tag selectors like button\n. This means that they emerge victorious from this confrontation, and our button would be painted blue.\nIn addition to the hierarchy of specificity (tag ‚Üí class ‚Üí id), there are also different groups of CSS, with different priority levels. This is technically a distinct concept from specificity, but it feels to me like a zoomed-out version of the same thing.\nFor example, every browser comes with a built-in set of CSS styles (‚Äúuser-agent‚Äù styles). This is why headings are bold by default, and why the <blockquote>\nelement looks different than a <p>\nelement. Instead of doing specificity math for each built-in style, the browser treats them as an entirely separate collection of CSS. They get applied first, and any CSS we write, no matter its specificity, will overwrite it.\nAnother example is the !important\nflag. Any CSS with this flag will be moved to its own high-priority collection of styles, automatically winning over any styles without !important\n, no matter their specificity.\nWhat about keyframe animations? These styles are also a distinct collection. That‚Äôs why we can do stuff like this:\n<style>\n@keyframes fadeFromTransparent {\nfrom {\nopacity: 0;\n}\n}\nh1 {\nanimation: fadeFromTransparent 1000ms;\n}\n#title {\nopacity: 1;\n}\n</style>\n<h1 id=\"title\"></h1>\nThis is interesting, when we think about it. Our fadeFromTransparent\nanimation changes the opacity\nproperty, and we‚Äôre doing it from within a tag selector (h1\n). But we‚Äôre also setting opacity\nto 1\nin an ID selector (#title\n). By the rules of specificity, that opacity: 1;\nshould overwrite the fade-in animation!\nThis works because the CSS declarations within keyframe animations are promoted to their own collection. This collection has the second-highest priority, just below !important\n. This means that our keyframe animations will almost always work. We don‚Äôt have to worry about any of this stuff when we use CSS keyframes.\nBut the same can‚Äôt be said for @starting-style\n! Unlike keyframe animations, the styles inside the @starting-style\nblock aren‚Äôt promoted. This means that the standard specificity rules apply.\nAs a result, our enter animation won‚Äôt run in cases like this:\nCode Playground\n<style> h1 { transition: opacity 500ms; @starting-style { opacity: 0; } } #title { opacity: 1; } </style> <h1 id=\"title\"> I don‚Äôt fade in :( </h1>\nWhen this heading is created, the browser runs its specificity calculations. Since #title\nis more specific than h1\n, the element is initialized with an opacity of 1\n, not 0\n.\nCSS transitions are only triggered when the applied styles change. In this setup, the opacity\nvalue is never actually set to 0, so there is no transition. The heading is painted immediately at full opacity.\nAdmittedly, this is a pretty contrived example, and most modern CSS approaches (Tailwind, styled-components, CSS Modules, BEM, etc) will protect you from these sorts of specificity issues. But even if you use one of these approaches, this gotcha can still getcha.\nLet‚Äôs look at a real-world example I ran into recently. In my upcoming course on whimsical animations(opens in new tab), we build this particle effect:\nWhen the user clicks the ‚ÄúLike‚Äù button, it generates 15-20 particles. They all start from the very center of the button and then expand outwards in a random direction by a random amount. This motion is accomplished using CSS transforms. So, for example, a particle might go from transform: translate(0px, 0px)\n(perfectly centered) to transform: translate(42px, -55px)\n(up and to the right).\nWhen I tried to use @starting-style\nfor this, it didn‚Äôt work. I spent a good few minutes completely baffled by it.\nThis particle effect is deceptively complex, and the full implementation is far too big to fit within this blog post, but I‚Äôve done my best to pluck out the bare essentials, so that we can see this issue in action:\nCode Playground\n<style> .particle { transition: transform 500ms; @starting-style { transform: translate(0px, 0px); } } </style> <button class=\"particleButton\"> <svg viewBox=\"0 0 24 24\" fill=\"none\" aria-hidden=\"true\" > <path d=\" M 3.5 5.5 C 8.6 1.3 11.9 7.4 12 7.4 C 12.2 7.4 15.5 1.3 20.4 5.4 C 26.9 10.9 13.5 21.8 12 21.8 C 10.6 21.8 -2.8 10.9 3.7 5.4 Z \" stroke=\"white\" stroke-width=\"2\" stroke-linecap=\"round\" /> </svg> <span class=\"visually-hidden\">Like this post</span> </button>\nTry clicking the button, and notice that the particles don‚Äôt ‚Äúpop‚Äù. They appear immediately in their final position, instead of animating from their starting position. Here‚Äôs what the expected result should be:\nIf we examine the code, we see that we‚Äôre setting the initial position in CSS with @starting-style\n. The ending position is dynamically generated for each particle, and set within /index.js\n:\nparticle.style.transform = `translate(\ncalc(cos(${angle}deg) * ${distance}px),\ncalc(sin(${angle}deg) * ${distance}px)\n)`;\nThe problem, once again, is related to specificity. When we set a style in JavaScript like this, it gets applied as an inline style, which is much more specific than the initial position, set in a CSS class (.particle\n). As a result, the starting styles never actually get applied to the particles.\nThis is a real-world example of the sort of subtle issue I ran into when I tried to use @starting-style\nin my own work. I consider myself reasonably adept at navigating specificity issues, but even still, this stuff really catches me off-guard!\nLink to this headingSolutions\nSo, that‚Äôs the problem. Thanks for bearing with me through that rather lengthy explanation. üòÖ\nLet‚Äôs talk about how we can address it.\nLink to this heading1. The nuclear option\nOne option to solve this problem is to increase the priority of the @starting-style\ndeclaration using !important\n:\n.particle {\ntransition: transform 500ms;\n@starting-style {\ntransform: translate(0px, 0px) !important;\n}\n}\nAs we briefly saw earlier, !important\npromotes the given CSS declaration to the highest-priority group, superseding all specificity calculations.\nThis works great, but whenever I use !important\n, it feels a bit like making a deal with the devil. It solves my problem today, but at a significant potential maintenance cost. It reduces the number of options available to us in the future, when we run into other specificity issues.\nGranted, in this particular case, it‚Äôs not quite so bad, since the starting styles are removed automatically right after the element is created. But it still doesn‚Äôt feel like a great solution.\nLink to this heading2: CSS custom properties\nA clever solution to this problem is to change how the final transform\ndeclaration is applied, using custom properties:\n/* /styles.css */\n.particle {\ntransform: translate(var(--x), var(--y));\ntransition: transform 500ms;\n@starting-style {\ntransform: translate(0px, 0px);\n}\n}\n/* /index.js */\nconst angle = random(0, 360);\nconst distance = random(32, 64);\nparticle.style.setProperty(\n'--x',\n`calc(cos(${angle}deg) * ${distance}px)`\n);\nparticle.style.setProperty(\n'--y',\n`calc(sin(${angle}deg) * ${distance}px)`\n);\nIn our JavaScript file, we create two new CSS custom properties (also known as CSS variables), --x\nand --y\n. We can then reference these values in our .particle\nclass styles!\nAs a result, our two transform\ndeclarations have the same specificity, and since the @starting-style\nis placed underneath the end transform\ndeclaration, everything works the way we‚Äôd expect.\nIn my opinion, this solution is very elegant. It sidesteps the core specificity issue in a very graceful way. But I don‚Äôt want my code to be elegant and graceful! I want my code to be as simple and basic as possible, so that it can be easily understood by the least-experienced members of my team, and so that I don‚Äôt have to burn a bunch of calories to figure out what‚Äôs going on when I revisit this code down the line.\nLink to this heading3: Using keyframes instead\nInstead of escalating things with !important\nor using a clever custom-property approach, we can always fall back on trusty CSS keyframes!\nCode Playground\n<style> @keyframes fromRestingPosition { from { transform: translate(0px, 0px); } } .particle { animation: fromRestingPosition 300ms; } </style> <button class=\"particleButton\"> <svg viewBox=\"0 0 24 24\" fill=\"none\" aria-hidden=\"true\" > <path d=\" M 3.5 5.5 C 8.6 1.3 11.9 7.4 12 7.4 C 12.2 7.4 15.5 1.3 20.4 5.4 C 26.9 10.9 13.5 21.8 12 21.8 C 10.6 21.8 -2.8 10.9 3.7 5.4 Z \" stroke=\"white\" stroke-width=\"2\" stroke-linecap=\"round\" /> </svg> <span class=\"visually-hidden\">Like this post</span> </button>\nLook at that! This approach works great. It only requires a couple lines of very basic CSS, and will be very easy to maintain. Plus, this approach will will work in virtually all browsers. @starting-style\nhas pretty good browser support, but it‚Äôll be many, many years until it‚Äôs as universal as keyframe animations.\nI think the appeal of @starting-style\nis that developers are already super comfortable with transitions, while CSS keyframes feel less flexible and less intuitive. But with modern CSS, I would argue that CSS keyframes are just as flexible as transitions, and even more powerful! In my opinion, keyframe animations are super underrated.\nI recently wrote about the cool things that we can do with keyframe animations. You can learn more here:\nLink to this headingSyntactic sugar?\nIt seems to me that @starting-style\ndoesn‚Äôt really open any new doors in terms of the sorts of animations we can create on the web. So far, all of the examples I‚Äôve seen could be accomplished using CSS keyframe animations. And as we‚Äôve seen in this blog post, it often winds up being simpler with keyframes!\nThis makes me think that maybe I‚Äôm missing something. Lots of the examples I see online combine @starting-style\nwith other modern CSS features, like transition-behavior: allow-discrete\nand interpolate-size: allow-keywords\n. But as far as I can tell, all of that stuff works equally well with keyframe animations. ü§î\nIf you know of something that can be accomplished exclusively using @starting-style\n, please let me know! You can shoot me an email or share it with me on Bluesky(opens in new tab).\nAnd either way, a big ‚Äúthank you‚Äù to all of the people who were involved in creating this and so many other modern CSS features. The pace of development has been unreal these last few years, and I can only imagine how much hard work goes into this. I‚Äôm very grateful for all of the new tools you‚Äôve given us. ‚ù§Ô∏è\nLink to this headingAn exciting announcement\nIf you‚Äôre familiar with my work, you know I care a lot about animations and interactions. I think they‚Äôre one of the most important ingredients when it comes to making polished products that feel great to use.\nFor the past year, I‚Äôve been working on something special. It‚Äôs an interactive online course called Whimsical Animations(opens in new tab).\nMy goal with this course is to share everything I‚Äôve learned about how to design and build next-level animations. If you‚Äôve ever wondered how I did something on this blog (or in my other projects), there‚Äôs a very good chance that you‚Äôll learn about it in my course.\nI‚Äôm hoping to release this course in the first half of 2026. You can learn more and sign up here:\nLast updated on\nOctober 28th, 2025",
  "metadata": {
    "site": "Josh W. Comeau"
  },
  "status": "ingested",
  "blog_content": null,
  "social_content": null,
  "google_doc_id": null,
  "error_message": null,
  "created_at": "2026-01-24T09:06:47.200124",
  "updated_at": "2026-01-24T09:06:47.200124"
}