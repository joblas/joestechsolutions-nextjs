{
  "id": "9deef333133066387e787db4dfb5c512",
  "source_type": "article",
  "source_url": "https://www.joshwcomeau.com/animation/linear-timing-function/",
  "title": "Springs and Bounces in Native CSS ‚Ä¢ Josh W. Comeau",
  "author": "Josh W Comeau",
  "publish_date": "2025-10-28T00:00:00",
  "raw_content": "---\ntitle: Springs and Bounces in Native CSS ‚Ä¢ Josh W. Comeau\nauthor: Josh W Comeau\ndescription: The ‚Äúlinear()‚Äù timing function is a game-changer; it allows us to model physics-based motion right in vanilla CSS! That said, there are some limitations and quirks to be aware of. I‚Äôve been experimenting with this API for a while now, and in this post, I‚Äôll share all of the tips and tricks I‚Äôve learned for using it effectively. ‚ú®\nsitename: Josh W. Comeau\ndate: 2025-10-28\n---\nWhen creating animations, we can decide how to transition between states using a timing function. Historically, we‚Äôve used B√©zier curves for this, which provide us with a range of different options:\nease-in\nease-in-out\nease\nIn this demo, each of these circles moves from side to side over the same duration, but they‚Äôre interpolated very differently. This can dramatically change how the animation feels.\nB√©zier curves are great, but there are certain things they just can‚Äôt do. For example:\nspring\nbounce\nIn the past, we‚Äôve needed to rely on JavaScript libraries to provide these sorts of interpolations, which introduces a whole bunch of trade-offs; most JavaScript animations run on the main thread, for example, which means they won‚Äôt run smoothly if other stuff is happening in our application!\nFortunately, modern CSS has provided us a new tool that enables us to create springs, bounces, and so much more all in native CSS: the linear()\ntiming function. In this blog post, I‚Äôll show you how it works, and share some tools you can use to get started right away!\nLink to this headingThe linear() function\nThe core idea here is surprisingly simple: instead of using mathematically-derived B√©zier curves, we can instead draw the easing curve we want, by specifying a set of individual points on a cartesian plane.\nFor example, this graph approximates an ‚Äúease‚Äù curve using 11 points:\nThis looks like a curve, but if you look closely, you‚Äôll notice that it‚Äôs actually a bunch of straight line segments. It‚Äôs like those ‚Äúconnect the dots‚Äù drawings, where a shape emerges from a bunch of straight lines.\nThis is why they named it ‚Äúlinear()‚Äù. Unlike B√©zier curves, which are actual mathematical curves, the linear()\nfunction only draws straight lines between a set of provided points.\nHere‚Äôs what the actual CSS looks like for the linear()\nanimation graphed above:\n.block {\ntransition:\ntransform 500ms linear(0, 0.1, 0.25, 0.5, 0.68, 0.8, 0.88, 0.94, 0.98, 0.995, 1);\n}\nThe linear()\nfunction takes a set of numbers, with 0 representing the starting value and 1 representing the final value. We can think of this as a ratio of the transition progress. We can pass as many numbers as we want, and they‚Äôll all be evenly-spaced across the specified duration.\nWe can use linear()\nto emulate spring physics, capturing the data from a real modeled spring. Let‚Äôs suppose we‚Äôre trying to recreate this springy motion:\nJust for fun, I did my best to trace that springy shape by hand, guesstimating 11 values based on that graph. Here‚Äôs what that looks like:\nYikes. This does not feel great. üòÇ\nWe‚Äôll look at how to make it better, but first, here‚Äôs the code for this not-great animation:\nlinear(0, 1.25, 1, 0.9, 1.04, 0.99, 1.005, 0.996, 1.001, 0.999, 1);\nLike with B√©zier curves, the linear()\nfunction allows us to pick values outside the 0 to 1 range, to overshoot the target like springs do. So that second value, 1.25\n, means that we‚Äôve overshot the target location by 25%.\nThe problem is that 11 values are just not enough to faithfully reproduce a springy value like this. The element is clearly moving robotically between discrete points rather than smoothly oscillating like a spring.\nBut if we crank up the number of points, the simulation becomes much more believable. I wrote some code to calculate the values for 50 points, and here‚Äôs the result:\nMuch more convincing, right?\nAs you can tell from my failed experiment above, we aren‚Äôt really meant to write these linear()\ndatasets by hand. Instead, we should use tools that dynamically calculate them for us.\nLink to this headingDynamically generating linear() values\nThe best tool I‚Äôve seen is Linear() Easing Generator(opens in new tab), by Jake Archibald and Adam Argyle. It comes pre-loaded with all of the math required to convert spring parameters into a highly-optimized linear()\nstring, and if you have another JS-based timing function, you can easily edit the code to use that instead!\nThere‚Äôs also Easing Wizard(opens in new tab), which is the most comprehensive and nicely-designed tool I‚Äôve found. It uses linear()\nto model springs, bounces, wiggles, and more, and provides a bunch of tools to test out your timing functions.\nBoth of these tools take advantage of a more-advanced syntax for the linear()\ntiming function. In addition to the progress ratio, certain points also have a time percentage:\n/* Example output from tool-generated linear() values: */\n.thing {\ntransition: transform 1500ms linear(\n0,\n0.013 0.6%,\n0.05 1.2%,\n0.2 2.5%,\n/* ‚úÇÔ∏è Buncha points omitted */\n0.971 47.2%,\n1.012 59.1%,\n0.995 70.8%,\n1\n);\n}\nLike before, we have a list of progress ratios from 0 to 1 (or beyond, for overshooting). Most of these points also have a second value, a percentage. This controls where each point is placed in time. So, rather than having a bunch of evenly-spaced values, we can position them strategically, to achieve the same curve with a smaller # of points.\nFor example, we can model that same spring with only 25 points, instead of 50:\nHonestly, I‚Äôm not sure that this is really much of a savings in terms of kilobytes; we use a smaller # of points, but each point requires two pieces of information instead of just one. Either way, both of the recommended tools use this syntax, so presumably they‚Äôve found that it‚Äôs beneficial!\nWe‚Äôll talk more about the performance implications shortly.\nLink to this headingLimitations\nThe linear()\nfunction is a lovely API that greatly expands what we can do in vanilla CSS, but like everything, there are some tradeoffs and limitations worth considering.\nLink to this heading1. It‚Äôs still time-based\nWhen using JavaScript libraries that implement physics-based animations like springs or bounces, we don‚Äôt specify an animation duration. Instead, we configure our animation using physical properties like stiffness, damping, and mass. The animation takes however long it takes based on the physics.\nThat‚Äôs not how CSS transitions work, though. CSS transitions require a duration:\n.elem {\ntransition: transform linear(...) 1200ms;\n}\nThe Linear() Easing Generator tool(opens in new tab) solves this by dynamically deriving a duration based on the provided spring settings. The duration is calculated based on how much time is necessary until the spring settles down and stops moving.\nThis works in most cases, but it means we can‚Äôt model a zero-friction spring. When we set ‚Äúdamping‚Äù to 0\n, the spring should oscillate forever, but there‚Äôs no such thing as an infinite-duration transition.\nEasing Wizard(opens in new tab) works a bit differently: ‚Äúduration‚Äù is a user-configurable parameter, and it doesn‚Äôt recalculate as we adjust the spring settings. To make this work, Easing Wizard fudges the numbers a bit. Certain parameters are internally clamped, so that they won‚Äôt produce impossible curves.\nFor example, with low mass/stiffness, damping has little to no effect, which is definitely not how it should work. üòÖ\nI prefer the solution that Jake/Adam came up with for Linear() Easing Generator, but really, there is no perfect solution here. Springs aren‚Äôt meant to be time-based, so it feels a bit like trying to come up with the best way to stuff a square peg into a round hole. It‚Äôs an awkward way to think about physics-based animation.\nLink to this heading2. Interrupts\nOne of the hardest problems in web animation is dealing with interrupts. The web is a dynamic place, and there‚Äôs no guarantee that an element will be allowed to complete its transition. Sometimes, it‚Äôll be updated halfway through. What should happen in that case?\nWell, let‚Äôs give it a shot. This demo implements the same basic transition using the linear()\nfunction as well as React Spring, a library based around JavaScript spring physics. Click the button quickly, to interrupt the transition:\nIf you click the button twice, very quickly, you should see something like this:\n(If you‚Äôre not able to click that quickly, you can also focus the button and press \"Enter\" twice.)\nWhen both animations run without interruption, they appear nearly identical. But if we trigger the button again mid-transition, they behave very differently.\nHere‚Äôs the fundamental difference: the version using React Spring takes the element‚Äôs current inertia into account. It takes a moment to slow down, before swinging back in the opposite direction. The CSS version, by contrast, turns around instantly, as though it hit a wall.\nAnd the CSS version‚Äôs behaviour feels unnatural. This spring is meant to be pretty loose and smooth, but on that rebound transition, it feels tight and quick. ü§î\nThe reason this happens is a bit complicated, and too much of a rabbit hole to get into here. To summarize at a high level, CSS transitions have special logic(opens in new tab) for handling interrupts. There‚Äôs a concept in the specification called the reversing shortening factor that proportionally reduces the duration of interrupted transitions. So, a spring intended to take 1600ms might re-run at only 400ms. This looks fine with B√©zier curves, but we‚Äôre trying to emulate physics here, and we can‚Äôt just speed it up and expect it to feel natural.\nIt‚Äôs a bit like taking a recording of someone walking at a leisurely pace, speeding it up by 2x, and trying to pass it off as someone jogging. The speed might be correct, but it sure as heck won‚Äôt look natural!\nLink to this heading3. Performance\nIn order to convincingly simulate a spring using linear()\n, we need lots of data points. It‚Äôs not uncommon for my springs to have 40+ data points!\nIt feels like this could have a significant impact on performance, but I wasn‚Äôt sure. And whenever I‚Äôm not sure about something like this, I try to figure it out with some testing.\nI had two main concerns:\n- Is the framerate affected by complex\nlinear()\nvalues? - Does it balloon the size of my CSS bundles?\nThe first concern was easy to test. I created a basic animation and tested two different linear()\nstrings. The first string was the simplest possible value, linear(0, 1)\n. The second string had >100 values.\nBoth animations ran equally smoothly, even on low-end hardware. I could not detect even a small difference between the two approaches. üëç\nFor the second concern, I created 3 maximum-accuracy springs with Easing Wizard, with an average of 75 values each, and added them to the CSS for my course platform. It‚Äôs important to test things like this in the context of a real application.\nHere are the resulting file sizes:\n- By default, my CSS bundle is 63.3kB, which compresses to 10.2kB with gzip.\n- With these extra springs, my CSS bundle grew to 67.1kB, which compresses to 11.5kB with gzip.\nSo, in this particular context, these 3 very-large springs added ~1.3kB to my CSS bundle.\nTo put that number in context: on a typical 3G connection (2mb/s), it will take 5ms (0.005 seconds) to download this extra chunk of CSS. It will also add some processing time on the device, but we‚Äôre still talking about a completely imperceptible amount of time.\nNow, this assumes we only have 3 linear()\nchunks in the entire bundle. If you copy/paste this large string for every animation, you could wind up with dozens of copies, so it‚Äôs a good idea to use CSS variables to reuse the same linear()\ntiming function in multiple places. Let‚Äôs talk about how to do that!\nLink to this headingUsing linear()\neffectively\nlinear()\nstrings tend to be big and unwieldy. In addition to the potential performance concerns, it‚Äôs also just kind of annoying to work with them!\nRather than sprinkle linear()\nvalues across the codebase, I recommend storing a handful of common timing functions in globally-available CSS variables. If you already have a system for design tokens, I think it‚Äôs a great idea to extend it with some linear()\ntiming functions!\nWe also need to consider browser support. As I mentioned earlier, linear()\nis a somewhat-new feature, and isn‚Äôt available in all browsers.\nOver the past few months, I‚Äôve been experimenting with how to use these timing functions effectively. Here‚Äôs the pattern I‚Äôve landed on:\nhtml {\n--spring-smooth: cubic-bezier(...);\n--spring-smooth-time: 1000ms;\n@supports (animation-timing-function: linear(0, 1)) {\n/* stiffness: 235, damping: 10 */\n/* prettier-ignore */\n--spring-smooth: linear(...);\n}\n}\n/* Then, to use this timing function: */\n@media (prefers-reduced-motion: no-preference) {\n.thing {\ntransition:\ntransform var(--spring-smooth) var(--spring-smooth-time);\n}\n}\nIf the user is using an older browser which doesn't support linear()\n, we‚Äôll provide a fallback transition using B√©zier curves. You can use Easing Wizard(opens in new tab) to come up with something that still feels alright (we can kinda mimic springs using B√©zier curves by overshooting the target; it doesn‚Äôt look anywhere near as smooth, but it‚Äôs a decent fallback option).\nThe @supports\nat-rule allows us to specify extra CSS in supported browsers. So, we overwrite --spring-smooth\nwith the actual linear()\nvalue. I also like to record the stiffness/damping for springs in a comment, so that if I want to adjust the spring settings in the future, I remember how to reconstruct this linear()\nstring. And finally, I add prettier-ignore\nto stop the Prettier formatter from putting each point on its own line, and turning this 1-line declaration into a 50-line list of numbers.\nWe can then use the --spring-smooth\nand --spring-smooth-time\nvariables wherever we typically apply transitions or keyframe animations. Like with all animations, we should make sure to respect user motion preferences. I write more about the ‚Äúprefers-reduced-motion‚Äù media query in my blog post, Accessible Animations in React (this post is mainly for React devs, but the first half of the post should still be useful for all web developers!).\nLink to this headingGoing deeper\nFor the past year, I‚Äôve been working on the ultimate animations course. ‚ú®\nIn this course, we use modern CSS features like linear()\nalongside JavaScript, SVG, and Canvas to create top-tier whimsical animations and interactions. I share all of the tips and tricks I‚Äôve learned after nearly two decades of experience.\nI‚Äôm hoping to release this course in the first half of 2026. You can learn more and sign up here:\nLast updated on\nOctober 28th, 2025",
  "metadata": {
    "site": "Josh W. Comeau"
  },
  "status": "ingested",
  "blog_content": null,
  "social_content": null,
  "google_doc_id": null,
  "error_message": null,
  "created_at": "2026-01-24T09:06:46.872201",
  "updated_at": "2026-01-24T09:06:46.872201"
}